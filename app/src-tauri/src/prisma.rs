// Code generated by Prisma Client Rust. DO NOT EDIT.

#![allow(warnings, unused)]
use prisma_client_rust::datamodel::parse_configuration;
use prisma_client_rust::prisma_models::InternalDataModelBuilder;
use prisma_client_rust::query::{
  transform_equals, Field, Input, Output, Query, QueryContext, Result as QueryResult,
};
use prisma_client_rust::query_core::{
  executor, schema_builder, BuildMode, CoreError, InterpreterError, QueryExecutor,
  QueryGraphBuilderError, QuerySchema,
};
use prisma_client_rust::{chrono, operator::Operator, serde_json, CountResult, Direction};
pub use prisma_client_rust::{query::Error as QueryError, NewClientError};
use serde::{Deserialize, Serialize};
use std::path::Path;
use std::sync::Arc;
static DATAMODEL_STR : & 'static str = "datasource db {\n  provider = \"sqlite\"\n  url      = \"file:dev.db\"\n}\n\ngenerator client {\n  provider = \"cargo prisma\"\n  output   = \"../app/src-tauri/src/prisma.rs\"\n}\n\nmodel TodoList {\n  id    Int @id @default(autoincrement())\n  name  String\n  todos TodoItem[]\n}\n\nmodel TodoItem {\n  id         Int @id @default(autoincrement())\n  todoList   TodoList @relation(fields: [todoListId], references: [id])\n  todoListId Int\n  text       String\n  complete   Boolean @default(false)\n}" ;
pub struct PrismaClient {
  executor: Box<dyn QueryExecutor + Send + Sync + 'static>,
  query_schema: Arc<QuerySchema>,
}
pub async fn new_client() -> Result<PrismaClient, NewClientError> {
  let config = parse_configuration(DATAMODEL_STR)?.subject;
  let source = config
    .datasources
    .first()
    .expect("Pleasy supply a datasource in your schema.prisma file");
  let url = if let Some(url) = source.load_shadow_database_url()? {
    url
  } else {
    source.load_url(|key| std::env::var(key).ok())?
  };
  let url = if url.starts_with("file:") {
    let path = url.split(":").nth(1).unwrap();
    if Path::new("./schema.prisma").exists() {
      url
    } else if Path::new("./prisma/schema.prisma").exists() {
      format!("file:./prisma/{}", path)
    } else {
      url
    }
  } else {
    url
  };
  new_client_with_url(&url).await
}
pub async fn new_client_with_url(url: &str) -> Result<PrismaClient, NewClientError> {
  let config = parse_configuration(DATAMODEL_STR)?.subject;
  let source = config
    .datasources
    .first()
    .expect("Pleasy supply a datasource in your schema.prisma file");
  let (db_name, executor) = executor::load(&source, &[], &url).await?;
  let internal_model = InternalDataModelBuilder::new(DATAMODEL_STR).build(db_name);
  let query_schema = Arc::new(schema_builder::build(
    internal_model,
    BuildMode::Modern,
    true,
    source.capabilities(),
    vec![],
    source.referential_integrity(),
  ));
  executor.primary_connector().get_connection().await?;
  Ok(PrismaClient {
    executor,
    query_schema,
  })
}
impl PrismaClient {
  pub async fn _query_raw<T: serde::de::DeserializeOwned>(
    &self,
    query: &str,
  ) -> QueryResult<Vec<T>> {
    let query = Query {
      ctx: QueryContext::new(&self.executor, self.query_schema.clone()),
      operation: "mutation".into(),
      method: "queryRaw".into(),
      inputs: vec![
        Input {
          name: "query".into(),
          value: Some(query.into()),
          ..Default::default()
        },
        Input {
          name: "parameters".into(),
          value: Some("[]".into()),
          ..Default::default()
        },
      ],
      name: "".into(),
      model: "".into(),
      outputs: vec![],
    };
    query.perform().await
  }
  pub async fn _execute_raw(&self, query: &str) -> QueryResult<i64> {
    let query = Query {
      ctx: QueryContext::new(&self.executor, self.query_schema.clone()),
      operation: "mutation".into(),
      method: "executeRaw".into(),
      inputs: vec![
        Input {
          name: "query".into(),
          value: Some(query.into()),
          ..Default::default()
        },
        Input {
          name: "parameters".into(),
          value: Some("[]".into()),
          ..Default::default()
        },
      ],
      name: "".into(),
      model: "".into(),
      outputs: vec![],
    };
    query.perform().await.map(|result: i64| result)
  }
  pub fn todo_list(&self) -> todo_list::Actions {
    todo_list::Actions { client: &self }
  }
  pub fn todo_item(&self) -> todo_item::Actions {
    todo_item::Actions { client: &self }
  }
}
pub mod todo_list {
  use super::*;
  pub mod id {
    use super::super::*;
    use super::{Cursor, OrderByParam, SetParam, UniqueWhereParam, WhereParam, WithParam};
    pub fn set<T: From<Set>>(value: i32) -> T {
      Set(value).into()
    }
    pub fn equals<T: From<UniqueWhereParam>>(value: i32) -> T {
      UniqueWhereParam::IdEquals(value).into()
    }
    pub fn order(direction: Direction) -> OrderByParam {
      OrderByParam::Id(direction)
    }
    pub fn cursor(cursor: i32) -> Cursor {
      Cursor::Id(cursor)
    }
    pub fn increment(value: i32) -> SetParam {
      SetParam::IncrementId(value)
    }
    pub fn decrement(value: i32) -> SetParam {
      SetParam::DecrementId(value)
    }
    pub fn multiply(value: i32) -> SetParam {
      SetParam::MultiplyId(value)
    }
    pub fn divide(value: i32) -> SetParam {
      SetParam::DivideId(value)
    }
    pub fn in_vec(value: Vec<i32>) -> WhereParam {
      WhereParam::IdInVec(value)
    }
    pub fn not_in_vec(value: Vec<i32>) -> WhereParam {
      WhereParam::IdNotInVec(value)
    }
    pub fn lt(value: i32) -> WhereParam {
      WhereParam::IdLt(value)
    }
    pub fn lte(value: i32) -> WhereParam {
      WhereParam::IdLte(value)
    }
    pub fn gt(value: i32) -> WhereParam {
      WhereParam::IdGt(value)
    }
    pub fn gte(value: i32) -> WhereParam {
      WhereParam::IdGte(value)
    }
    pub fn not(value: i32) -> WhereParam {
      WhereParam::IdNot(value)
    }
    pub struct Set(i32);
    impl From<Set> for SetParam {
      fn from(value: Set) -> Self {
        Self::SetId(value.0)
      }
    }
  }
  pub mod name {
    use super::super::*;
    use super::{Cursor, OrderByParam, SetParam, UniqueWhereParam, WhereParam, WithParam};
    pub fn set<T: From<Set>>(value: String) -> T {
      Set(value).into()
    }
    pub fn equals(value: String) -> WhereParam {
      WhereParam::NameEquals(value).into()
    }
    pub fn order(direction: Direction) -> OrderByParam {
      OrderByParam::Name(direction)
    }
    pub fn in_vec(value: Vec<String>) -> WhereParam {
      WhereParam::NameInVec(value)
    }
    pub fn not_in_vec(value: Vec<String>) -> WhereParam {
      WhereParam::NameNotInVec(value)
    }
    pub fn lt(value: String) -> WhereParam {
      WhereParam::NameLt(value)
    }
    pub fn lte(value: String) -> WhereParam {
      WhereParam::NameLte(value)
    }
    pub fn gt(value: String) -> WhereParam {
      WhereParam::NameGt(value)
    }
    pub fn gte(value: String) -> WhereParam {
      WhereParam::NameGte(value)
    }
    pub fn contains(value: String) -> WhereParam {
      WhereParam::NameContains(value)
    }
    pub fn starts_with(value: String) -> WhereParam {
      WhereParam::NameStartsWith(value)
    }
    pub fn ends_with(value: String) -> WhereParam {
      WhereParam::NameEndsWith(value)
    }
    pub fn not(value: String) -> WhereParam {
      WhereParam::NameNot(value)
    }
    pub struct Set(String);
    impl From<Set> for SetParam {
      fn from(value: Set) -> Self {
        Self::SetName(value.0)
      }
    }
  }
  pub mod todos {
    use super::super::*;
    use super::{Cursor, OrderByParam, SetParam, UniqueWhereParam, WhereParam, WithParam};
    pub fn some(value: Vec<todo_item::WhereParam>) -> WhereParam {
      WhereParam::TodosSome(value)
    }
    pub fn every(value: Vec<todo_item::WhereParam>) -> WhereParam {
      WhereParam::TodosEvery(value)
    }
    pub fn none(value: Vec<todo_item::WhereParam>) -> WhereParam {
      WhereParam::TodosNone(value)
    }
    pub fn fetch(params: Vec<todo_item::WhereParam>) -> WithParam {
      WithParam::Todos(params)
    }
    pub fn link<T: From<Link>>(params: Vec<todo_item::UniqueWhereParam>) -> T {
      Link(params).into()
    }
    pub fn unlink(params: Vec<todo_item::UniqueWhereParam>) -> SetParam {
      SetParam::UnlinkTodos(params)
    }
    pub struct Link(Vec<todo_item::UniqueWhereParam>);
    impl From<Link> for SetParam {
      fn from(value: Link) -> Self {
        Self::LinkTodos(value.0)
      }
    }
  }
  pub fn _outputs() -> Vec<Output> {
    vec![Output::new("id"), Output::new("name")]
  }
  #[derive(Debug, Clone, Serialize, Deserialize)]
  pub struct Data {
    #[serde(rename = "id")]
    pub id: i32,
    #[serde(rename = "name")]
    pub name: String,
    #[serde(rename = "todos")]
    todos: Option<Vec<super::todo_item::Data>>,
  }
  impl Data {
    pub fn todos(&self) -> Result<&Vec<super::todo_item::Data>, String> {
      match self.todos.as_ref() {
        Some(v) => Ok(v),
        None => {
          Err("Attempted to access todos but did not fetch it using the .with() syntax".to_string())
        }
      }
    }
  }
  pub enum WithParam {
    Todos(Vec<super::todo_item::WhereParam>),
  }
  impl WithParam {
    pub fn to_output(self) -> Output {
      match self {
        Self::Todos(where_params) => Output {
          name: "todos".into(),
          outputs: super::todo_item::_outputs(),
          inputs: if where_params.len() > 0 {
            vec![Input {
              name: "where".into(),
              fields: where_params
                .into_iter()
                .map(|param| Into::<super::todo_item::WhereParam>::into(param).to_field())
                .collect(),
              ..Default::default()
            }]
          } else {
            vec![]
          },
          ..Default::default()
        },
      }
    }
  }
  pub enum SetParam {
    SetId(i32),
    IncrementId(i32),
    DecrementId(i32),
    MultiplyId(i32),
    DivideId(i32),
    SetName(String),
    LinkTodos(Vec<super::todo_item::UniqueWhereParam>),
    UnlinkTodos(Vec<super::todo_item::UniqueWhereParam>),
  }
  impl SetParam {
    pub fn to_field(self) -> Field {
      match self {
        Self::SetId(value) => Field {
          name: "id".into(),
          value: Some(serde_json::to_value(value).unwrap()),
          ..Default::default()
        },
        Self::IncrementId(value) => Field {
          name: "id".into(),
          fields: Some(vec![Field {
            name: "increment".into(),
            value: Some(serde_json::to_value(value).unwrap()),
            ..Default::default()
          }]),
          ..Default::default()
        },
        Self::DecrementId(value) => Field {
          name: "id".into(),
          fields: Some(vec![Field {
            name: "decrement".into(),
            value: Some(serde_json::to_value(value).unwrap()),
            ..Default::default()
          }]),
          ..Default::default()
        },
        Self::MultiplyId(value) => Field {
          name: "id".into(),
          fields: Some(vec![Field {
            name: "multiply".into(),
            value: Some(serde_json::to_value(value).unwrap()),
            ..Default::default()
          }]),
          ..Default::default()
        },
        Self::DivideId(value) => Field {
          name: "id".into(),
          fields: Some(vec![Field {
            name: "divide".into(),
            value: Some(serde_json::to_value(value).unwrap()),
            ..Default::default()
          }]),
          ..Default::default()
        },
        Self::SetName(value) => Field {
          name: "name".into(),
          value: Some(serde_json::to_value(value).unwrap()),
          ..Default::default()
        },
        Self::LinkTodos(where_params) => Field {
          name: "todos".into(),
          fields: Some(vec![Field {
            name: "connect".into(),
            fields: Some(transform_equals(
              where_params
                .into_iter()
                .map(|param| Into::<super::todo_item::WhereParam>::into(param).to_field())
                .collect(),
            )),
            list: true,
            wrap_list: true,
            ..Default::default()
          }]),
          ..Default::default()
        },
        Self::UnlinkTodos(where_params) => Field {
          name: "todos".into(),
          fields: Some(vec![Field {
            name: "disconnect".into(),
            list: true,
            wrap_list: true,
            fields: Some(transform_equals(
              where_params
                .into_iter()
                .map(|param| Into::<super::todo_item::WhereParam>::into(param).to_field())
                .collect(),
            )),
            ..Default::default()
          }]),
          ..Default::default()
        },
      }
    }
  }
  pub enum OrderByParam {
    Id(Direction),
    Name(Direction),
  }
  impl OrderByParam {
    pub fn to_field(self) -> Field {
      match self {
        Self::Id(direction) => Field {
          name: "id".into(),
          value: Some(serde_json::to_value(direction).unwrap()),
          ..Default::default()
        },
        Self::Name(direction) => Field {
          name: "name".into(),
          value: Some(serde_json::to_value(direction).unwrap()),
          ..Default::default()
        },
      }
    }
  }
  pub enum Cursor {
    Id(i32),
    Name(String),
  }
  impl Cursor {
    fn to_field(self) -> Field {
      match self {
        Self::Id(value) => Field {
          name: "id".into(),
          value: Some(serde_json::to_value(value).unwrap()),
          ..Default::default()
        },
        Self::Name(value) => Field {
          name: "name".into(),
          value: Some(serde_json::to_value(value).unwrap()),
          ..Default::default()
        },
      }
    }
  }
  pub enum WhereParam {
    Not(Vec<WhereParam>),
    Or(Vec<WhereParam>),
    And(Vec<WhereParam>),
    IdEquals(i32),
    IdInVec(Vec<i32>),
    IdNotInVec(Vec<i32>),
    IdLt(i32),
    IdLte(i32),
    IdGt(i32),
    IdGte(i32),
    IdNot(i32),
    NameEquals(String),
    NameInVec(Vec<String>),
    NameNotInVec(Vec<String>),
    NameLt(String),
    NameLte(String),
    NameGt(String),
    NameGte(String),
    NameContains(String),
    NameStartsWith(String),
    NameEndsWith(String),
    NameNot(String),
    TodosSome(Vec<super::todo_item::WhereParam>),
    TodosEvery(Vec<super::todo_item::WhereParam>),
    TodosNone(Vec<super::todo_item::WhereParam>),
  }
  impl WhereParam {
    pub fn to_field(self) -> Field {
      match self {
        Self::Not(value) => Field {
          name: "NOT".into(),
          list: true,
          wrap_list: true,
          fields: Some(value.into_iter().map(|f| f.to_field()).collect()),
          ..Default::default()
        },
        Self::Or(value) => Field {
          name: "OR".into(),
          list: true,
          wrap_list: true,
          fields: Some(value.into_iter().map(|f| f.to_field()).collect()),
          ..Default::default()
        },
        Self::And(value) => Field {
          name: "AND".into(),
          list: true,
          wrap_list: true,
          fields: Some(value.into_iter().map(|f| f.to_field()).collect()),
          ..Default::default()
        },
        Self::IdEquals(value) => Field {
          name: "id".into(),
          fields: Some(vec![Field {
            name: "equals".into(),
            value: Some(serde_json::to_value(value).unwrap()),
            ..Default::default()
          }]),
          ..Default::default()
        },
        Self::IdInVec(value) => Field {
          name: "id".into(),
          fields: Some(vec![Field {
            name: "in".into(),
            list: true,
            fields: Some(
              value
                .iter()
                .map(|v| Field {
                  value: Some(serde_json::to_value(v).unwrap()),
                  ..Default::default()
                })
                .collect(),
            ),
            ..Default::default()
          }]),
          ..Default::default()
        },
        Self::IdNotInVec(value) => Field {
          name: "id".into(),
          fields: Some(vec![Field {
            name: "notIn".into(),
            list: true,
            fields: Some(
              value
                .iter()
                .map(|v| Field {
                  value: Some(serde_json::to_value(v).unwrap()),
                  ..Default::default()
                })
                .collect(),
            ),
            ..Default::default()
          }]),
          ..Default::default()
        },
        Self::IdLt(value) => Field {
          name: "id".into(),
          fields: Some(vec![Field {
            name: "lt".into(),
            value: Some(serde_json::to_value(value).unwrap()),
            ..Default::default()
          }]),
          ..Default::default()
        },
        Self::IdLte(value) => Field {
          name: "id".into(),
          fields: Some(vec![Field {
            name: "lte".into(),
            value: Some(serde_json::to_value(value).unwrap()),
            ..Default::default()
          }]),
          ..Default::default()
        },
        Self::IdGt(value) => Field {
          name: "id".into(),
          fields: Some(vec![Field {
            name: "gt".into(),
            value: Some(serde_json::to_value(value).unwrap()),
            ..Default::default()
          }]),
          ..Default::default()
        },
        Self::IdGte(value) => Field {
          name: "id".into(),
          fields: Some(vec![Field {
            name: "gte".into(),
            value: Some(serde_json::to_value(value).unwrap()),
            ..Default::default()
          }]),
          ..Default::default()
        },
        Self::IdNot(value) => Field {
          name: "id".into(),
          fields: Some(vec![Field {
            name: "not".into(),
            value: Some(serde_json::to_value(value).unwrap()),
            ..Default::default()
          }]),
          ..Default::default()
        },
        Self::NameEquals(value) => Field {
          name: "name".into(),
          fields: Some(vec![Field {
            name: "equals".into(),
            value: Some(serde_json::to_value(value).unwrap()),
            ..Default::default()
          }]),
          ..Default::default()
        },
        Self::NameInVec(value) => Field {
          name: "name".into(),
          fields: Some(vec![Field {
            name: "in".into(),
            list: true,
            fields: Some(
              value
                .iter()
                .map(|v| Field {
                  value: Some(serde_json::to_value(v).unwrap()),
                  ..Default::default()
                })
                .collect(),
            ),
            ..Default::default()
          }]),
          ..Default::default()
        },
        Self::NameNotInVec(value) => Field {
          name: "name".into(),
          fields: Some(vec![Field {
            name: "notIn".into(),
            list: true,
            fields: Some(
              value
                .iter()
                .map(|v| Field {
                  value: Some(serde_json::to_value(v).unwrap()),
                  ..Default::default()
                })
                .collect(),
            ),
            ..Default::default()
          }]),
          ..Default::default()
        },
        Self::NameLt(value) => Field {
          name: "name".into(),
          fields: Some(vec![Field {
            name: "lt".into(),
            value: Some(serde_json::to_value(value).unwrap()),
            ..Default::default()
          }]),
          ..Default::default()
        },
        Self::NameLte(value) => Field {
          name: "name".into(),
          fields: Some(vec![Field {
            name: "lte".into(),
            value: Some(serde_json::to_value(value).unwrap()),
            ..Default::default()
          }]),
          ..Default::default()
        },
        Self::NameGt(value) => Field {
          name: "name".into(),
          fields: Some(vec![Field {
            name: "gt".into(),
            value: Some(serde_json::to_value(value).unwrap()),
            ..Default::default()
          }]),
          ..Default::default()
        },
        Self::NameGte(value) => Field {
          name: "name".into(),
          fields: Some(vec![Field {
            name: "gte".into(),
            value: Some(serde_json::to_value(value).unwrap()),
            ..Default::default()
          }]),
          ..Default::default()
        },
        Self::NameContains(value) => Field {
          name: "name".into(),
          fields: Some(vec![Field {
            name: "contains".into(),
            value: Some(serde_json::to_value(value).unwrap()),
            ..Default::default()
          }]),
          ..Default::default()
        },
        Self::NameStartsWith(value) => Field {
          name: "name".into(),
          fields: Some(vec![Field {
            name: "startsWith".into(),
            value: Some(serde_json::to_value(value).unwrap()),
            ..Default::default()
          }]),
          ..Default::default()
        },
        Self::NameEndsWith(value) => Field {
          name: "name".into(),
          fields: Some(vec![Field {
            name: "endsWith".into(),
            value: Some(serde_json::to_value(value).unwrap()),
            ..Default::default()
          }]),
          ..Default::default()
        },
        Self::NameNot(value) => Field {
          name: "name".into(),
          fields: Some(vec![Field {
            name: "not".into(),
            value: Some(serde_json::to_value(value).unwrap()),
            ..Default::default()
          }]),
          ..Default::default()
        },
        Self::TodosSome(value) => Field {
          name: "todos".into(),
          fields: Some(vec![Field {
            name: "some".into(),
            fields: Some(value.into_iter().map(|f| f.to_field()).collect()),
            ..Default::default()
          }]),
          ..Default::default()
        },
        Self::TodosEvery(value) => Field {
          name: "todos".into(),
          fields: Some(vec![Field {
            name: "every".into(),
            fields: Some(value.into_iter().map(|f| f.to_field()).collect()),
            ..Default::default()
          }]),
          ..Default::default()
        },
        Self::TodosNone(value) => Field {
          name: "todos".into(),
          fields: Some(vec![Field {
            name: "none".into(),
            fields: Some(value.into_iter().map(|f| f.to_field()).collect()),
            ..Default::default()
          }]),
          ..Default::default()
        },
      }
    }
  }
  pub enum UniqueWhereParam {
    IdEquals(i32),
  }
  impl From<UniqueWhereParam> for WhereParam {
    fn from(value: UniqueWhereParam) -> Self {
      match value {
        UniqueWhereParam::IdEquals(value) => Self::IdEquals(value),
      }
    }
  }
  impl From<Operator<Self>> for WhereParam {
    fn from(op: Operator<Self>) -> Self {
      match op {
        Operator::Not(value) => Self::Not(value),
        Operator::And(value) => Self::And(value),
        Operator::Or(value) => Self::Or(value),
      }
    }
  }
  pub struct FindMany<'a> {
    query: Query<'a>,
    order_by_params: Vec<OrderByParam>,
    with_params: Vec<WithParam>,
  }
  impl<'a> FindMany<'a> {
    pub async fn exec(self) -> QueryResult<Vec<Data>> {
      let Self {
        mut query,
        order_by_params,
        with_params,
      } = self;
      if order_by_params.len() > 0 {
        query.inputs.push(Input {
          name: "orderBy".into(),
          fields: order_by_params.into_iter().map(|f| f.to_field()).collect(),
          ..Default::default()
        });
      }
      query.outputs.extend(
        with_params
          .into_iter()
          .map(|f| f.to_output())
          .collect::<Vec<_>>(),
      );
      query.perform().await
    }
    pub fn delete(self) -> DeleteMany<'a> {
      DeleteMany {
        query: Query {
          operation: "mutation".into(),
          method: "deleteMany".into(),
          model: "TodoList".into(),
          outputs: vec![Output::new("count")],
          ..self.query
        },
      }
    }
    pub fn update(mut self, params: Vec<SetParam>) -> UpdateMany<'a> {
      self.query.inputs.push(Input {
        name: "data".into(),
        fields: params
          .into_iter()
          .map(|param| {
            let mut field = param.to_field();
            if let Some(value) = field.value {
              field.fields = Some(vec![Field {
                name: "set".into(),
                value: Some(value),
                ..Default::default()
              }]);
              field.value = None;
            }
            field
          })
          .collect(),
        ..Default::default()
      });
      UpdateMany {
        query: Query {
          operation: "mutation".into(),
          method: "updateMany".into(),
          outputs: vec![Output::new("count")],
          ..self.query
        },
      }
    }
    pub fn order_by(mut self, param: OrderByParam) -> Self {
      self.order_by_params.push(param);
      self
    }
    pub fn with(mut self, param: WithParam) -> Self {
      self.with_params.push(param);
      self
    }
    pub fn skip(mut self, skip: usize) -> Self {
      self.query.inputs.push(Input {
        name: "skip".into(),
        value: Some(serde_json::to_value(skip).unwrap()),
        ..Default::default()
      });
      self
    }
    pub fn take(mut self, take: usize) -> Self {
      self.query.inputs.push(Input {
        name: "take".into(),
        value: Some(serde_json::to_value(take).unwrap()),
        ..Default::default()
      });
      self
    }
    pub fn cursor(mut self, cursor: Cursor) -> Self {
      self.query.inputs.push(Input {
        name: "cursor".into(),
        fields: vec![cursor.to_field()],
        ..Default::default()
      });
      self
    }
  }
  pub struct FindFirst<'a> {
    query: Query<'a>,
    order_by_params: Vec<OrderByParam>,
    with_params: Vec<WithParam>,
  }
  impl<'a> FindFirst<'a> {
    pub async fn exec(self) -> QueryResult<Option<Data>> {
      let Self {
        mut query,
        order_by_params,
        with_params,
      } = self;
      if order_by_params.len() > 0 {
        query.inputs.push(Input {
          name: "orderBy".into(),
          fields: order_by_params.into_iter().map(|f| f.to_field()).collect(),
          ..Default::default()
        });
      }
      query.outputs.extend(
        with_params
          .into_iter()
          .map(|f| f.to_output())
          .collect::<Vec<_>>(),
      );
      query.perform().await
    }
    pub fn with(mut self, param: WithParam) -> Self {
      self.with_params.push(param);
      self
    }
    pub fn order_by(mut self, param: OrderByParam) -> Self {
      self.order_by_params.push(param);
      self
    }
    pub fn skip(mut self, skip: usize) -> Self {
      self.query.inputs.push(Input {
        name: "skip".into(),
        value: Some(serde_json::to_value(skip).unwrap()),
        ..Default::default()
      });
      self
    }
    pub fn take(mut self, take: usize) -> Self {
      self.query.inputs.push(Input {
        name: "take".into(),
        value: Some(serde_json::to_value(take).unwrap()),
        ..Default::default()
      });
      self
    }
    pub fn cursor(mut self, cursor: Cursor) -> Self {
      self.query.inputs.push(Input {
        name: "cursor".into(),
        fields: vec![cursor.to_field()],
        ..Default::default()
      });
      self
    }
  }
  pub struct FindUnique<'a> {
    query: Query<'a>,
    with_params: Vec<WithParam>,
  }
  impl<'a> FindUnique<'a> {
    pub async fn exec(self) -> QueryResult<Option<Data>> {
      let Self {
        mut query,
        with_params,
      } = self;
      query.outputs.extend(
        with_params
          .into_iter()
          .map(|f| f.to_output())
          .collect::<Vec<_>>(),
      );
      query.perform().await
    }
    pub fn delete(self) -> Delete<'a> {
      Delete {
        query: Query {
          operation: "mutation".into(),
          method: "deleteOne".into(),
          model: "TodoList".into(),
          ..self.query
        },
        with_params: vec![],
      }
    }
    pub fn update(mut self, params: Vec<SetParam>) -> UpdateUnique<'a> {
      self.query.inputs.push(Input {
        name: "data".into(),
        fields: params
          .into_iter()
          .map(|param| {
            let mut field = param.to_field();
            if let Some(value) = field.value {
              field.fields = Some(vec![Field {
                name: "set".into(),
                value: Some(value),
                ..Default::default()
              }]);
              field.value = None;
            }
            field
          })
          .collect(),
        ..Default::default()
      });
      UpdateUnique {
        query: Query {
          operation: "mutation".into(),
          method: "updateOne".into(),
          ..self.query
        },
        with_params: vec![],
      }
    }
    pub fn with(mut self, param: WithParam) -> Self {
      self.with_params.push(param);
      self
    }
  }
  pub struct Create<'a> {
    query: Query<'a>,
    with_params: Vec<WithParam>,
  }
  impl<'a> Create<'a> {
    pub async fn exec(self) -> QueryResult<Data> {
      let Self {
        mut query,
        with_params,
      } = self;
      query.outputs.extend(
        with_params
          .into_iter()
          .map(|f| f.to_output())
          .collect::<Vec<_>>(),
      );
      query.perform().await
    }
    pub fn with(mut self, param: WithParam) -> Self {
      self.with_params.push(param);
      self
    }
  }
  pub struct UpdateUnique<'a> {
    query: Query<'a>,
    with_params: Vec<WithParam>,
  }
  impl<'a> UpdateUnique<'a> {
    pub async fn exec(self) -> QueryResult<Option<Data>> {
      let Self {
        mut query,
        with_params,
      } = self;
      query.outputs.extend(
        with_params
          .into_iter()
          .map(|f| f.to_output())
          .collect::<Vec<_>>(),
      );
      match query.perform().await {
        Err(QueryError::Execute(CoreError::InterpreterError(
          InterpreterError::InterpretationError(msg, Some(interpreter_error)),
        ))) => match *interpreter_error {
          InterpreterError::QueryGraphBuilderError(QueryGraphBuilderError::RecordNotFound(_)) => {
            Ok(None)
          }
          res => Err(QueryError::Execute(CoreError::InterpreterError(
            InterpreterError::InterpretationError(msg, Some(Box::new(res))),
          ))),
        },
        res => res,
      }
    }
    pub fn with(mut self, param: WithParam) -> Self {
      self.with_params.push(param);
      self
    }
  }
  pub struct UpdateMany<'a> {
    query: Query<'a>,
  }
  impl<'a> UpdateMany<'a> {
    pub async fn exec(self) -> QueryResult<usize> {
      self.query.perform().await.map(|res: CountResult| res.count)
    }
  }
  pub struct Upsert<'a> {
    query: Query<'a>,
  }
  impl<'a> Upsert<'a> {
    pub async fn exec(self) -> QueryResult<Data> {
      self.query.perform().await
    }
    pub fn create(mut self, name: name::Set, params: Vec<SetParam>) -> Self {
      let mut input_fields = params.into_iter().map(|p| p.to_field()).collect::<Vec<_>>();
      input_fields.push(SetParam::from(name).to_field());
      self.query.inputs.push(Input {
        name: "create".into(),
        fields: input_fields,
        ..Default::default()
      });
      self
    }
    pub fn update(mut self, params: Vec<SetParam>) -> Self {
      self.query.inputs.push(Input {
        name: "update".into(),
        fields: params
          .into_iter()
          .map(|param| {
            let mut field = param.to_field();
            if let Some(value) = field.value {
              field.fields = Some(vec![Field {
                name: "set".into(),
                value: Some(value),
                ..Default::default()
              }]);
              field.value = None;
            }
            field
          })
          .collect(),
        ..Default::default()
      });
      self
    }
  }
  pub struct Delete<'a> {
    query: Query<'a>,
    with_params: Vec<WithParam>,
  }
  impl<'a> Delete<'a> {
    pub async fn exec(self) -> QueryResult<Option<Data>> {
      let Self {
        mut query,
        with_params,
      } = self;
      query.outputs.extend(
        with_params
          .into_iter()
          .map(|f| f.to_output())
          .collect::<Vec<_>>(),
      );
      match query.perform().await {
        Err(QueryError::Execute(CoreError::InterpreterError(
          InterpreterError::InterpretationError(msg, Some(interpreter_error)),
        ))) => match *interpreter_error {
          InterpreterError::QueryGraphBuilderError(QueryGraphBuilderError::RecordNotFound(_)) => {
            Ok(None)
          }
          res => Err(QueryError::Execute(CoreError::InterpreterError(
            InterpreterError::InterpretationError(msg, Some(Box::new(res))),
          ))),
        },
        res => res,
      }
    }
    pub fn with(mut self, param: WithParam) -> Self {
      self.with_params.push(param);
      self
    }
  }
  pub struct DeleteMany<'a> {
    query: Query<'a>,
  }
  impl<'a> DeleteMany<'a> {
    pub async fn exec(self) -> QueryResult<usize> {
      self.query.perform().await.map(|res: CountResult| res.count)
    }
  }
  pub struct Actions<'a> {
    pub client: &'a PrismaClient,
  }
  impl<'a> Actions<'a> {
    pub fn create(&self, name: name::Set, params: Vec<SetParam>) -> Create {
      let mut input_fields = params.into_iter().map(|p| p.to_field()).collect::<Vec<_>>();
      input_fields.push(SetParam::from(name).to_field());
      let query = Query {
        ctx: QueryContext::new(&self.client.executor, self.client.query_schema.clone()),
        name: String::new(),
        operation: "mutation".into(),
        method: "createOne".into(),
        model: "TodoList".into(),
        outputs: _outputs(),
        inputs: vec![Input {
          name: "data".into(),
          fields: input_fields,
          ..Default::default()
        }],
      };
      Create {
        query,
        with_params: vec![],
      }
    }
    pub fn find_unique(&self, param: UniqueWhereParam) -> FindUnique {
      let param: WhereParam = param.into();
      let fields = transform_equals(vec![param.to_field()]);
      let query = Query {
        ctx: QueryContext::new(&self.client.executor, self.client.query_schema.clone()),
        name: String::new(),
        operation: "query".into(),
        method: "findUnique".into(),
        model: "TodoList".into(),
        outputs: _outputs(),
        inputs: vec![Input {
          name: "where".into(),
          fields,
          ..Default::default()
        }],
      };
      FindUnique {
        query,
        with_params: vec![],
      }
    }
    pub fn find_first(&self, params: Vec<WhereParam>) -> FindFirst {
      let where_fields: Vec<Field> = params.into_iter().map(|param| param.to_field()).collect();
      let inputs = if where_fields.len() > 0 {
        vec![Input {
          name: "where".into(),
          fields: vec![Field {
            name: "AND".into(),
            list: true,
            wrap_list: true,
            fields: Some(where_fields),
            ..Default::default()
          }],
          ..Default::default()
        }]
      } else {
        Vec::new()
      };
      let query = Query {
        ctx: QueryContext::new(&self.client.executor, self.client.query_schema.clone()),
        name: String::new(),
        operation: "query".into(),
        method: "findFirst".into(),
        model: "TodoList".into(),
        outputs: _outputs(),
        inputs,
      };
      FindFirst {
        query,
        order_by_params: vec![],
        with_params: vec![],
      }
    }
    pub fn find_many(&self, params: Vec<WhereParam>) -> FindMany {
      let where_fields: Vec<Field> = params.into_iter().map(|param| param.to_field()).collect();
      let inputs = if where_fields.len() > 0 {
        vec![Input {
          name: "where".into(),
          fields: where_fields,
          ..Default::default()
        }]
      } else {
        Vec::new()
      };
      let query = Query {
        ctx: QueryContext::new(&self.client.executor, self.client.query_schema.clone()),
        name: String::new(),
        operation: "query".into(),
        method: "findMany".into(),
        model: "TodoList".into(),
        outputs: _outputs(),
        inputs,
      };
      FindMany {
        query,
        order_by_params: vec![],
        with_params: vec![],
      }
    }
    pub fn upsert(&self, param: UniqueWhereParam) -> Upsert {
      let param: WhereParam = param.into();
      let fields = transform_equals(vec![param.to_field()]);
      let query = Query {
        ctx: QueryContext::new(&self.client.executor, self.client.query_schema.clone()),
        name: String::new(),
        operation: "mutation".into(),
        method: "upsertOne".into(),
        model: "TodoList".into(),
        outputs: _outputs(),
        inputs: vec![Input {
          name: "where".into(),
          fields,
          ..Default::default()
        }],
      };
      Upsert { query }
    }
  }
}
pub mod todo_item {
  use super::*;
  pub mod id {
    use super::super::*;
    use super::{Cursor, OrderByParam, SetParam, UniqueWhereParam, WhereParam, WithParam};
    pub fn set<T: From<Set>>(value: i32) -> T {
      Set(value).into()
    }
    pub fn equals<T: From<UniqueWhereParam>>(value: i32) -> T {
      UniqueWhereParam::IdEquals(value).into()
    }
    pub fn order(direction: Direction) -> OrderByParam {
      OrderByParam::Id(direction)
    }
    pub fn cursor(cursor: i32) -> Cursor {
      Cursor::Id(cursor)
    }
    pub fn increment(value: i32) -> SetParam {
      SetParam::IncrementId(value)
    }
    pub fn decrement(value: i32) -> SetParam {
      SetParam::DecrementId(value)
    }
    pub fn multiply(value: i32) -> SetParam {
      SetParam::MultiplyId(value)
    }
    pub fn divide(value: i32) -> SetParam {
      SetParam::DivideId(value)
    }
    pub fn in_vec(value: Vec<i32>) -> WhereParam {
      WhereParam::IdInVec(value)
    }
    pub fn not_in_vec(value: Vec<i32>) -> WhereParam {
      WhereParam::IdNotInVec(value)
    }
    pub fn lt(value: i32) -> WhereParam {
      WhereParam::IdLt(value)
    }
    pub fn lte(value: i32) -> WhereParam {
      WhereParam::IdLte(value)
    }
    pub fn gt(value: i32) -> WhereParam {
      WhereParam::IdGt(value)
    }
    pub fn gte(value: i32) -> WhereParam {
      WhereParam::IdGte(value)
    }
    pub fn not(value: i32) -> WhereParam {
      WhereParam::IdNot(value)
    }
    pub struct Set(i32);
    impl From<Set> for SetParam {
      fn from(value: Set) -> Self {
        Self::SetId(value.0)
      }
    }
  }
  pub mod todo_list {
    use super::super::*;
    use super::{Cursor, OrderByParam, SetParam, UniqueWhereParam, WhereParam, WithParam};
    pub fn is(value: Vec<todo_list::WhereParam>) -> WhereParam {
      WhereParam::TodoListIs(value)
    }
    pub fn is_not(value: Vec<todo_list::WhereParam>) -> WhereParam {
      WhereParam::TodoListIsNot(value)
    }
    pub fn fetch() -> WithParam {
      WithParam::TodoList
    }
    pub fn link<T: From<Link>>(value: todo_list::UniqueWhereParam) -> T {
      Link(value).into()
    }
    pub struct Link(todo_list::UniqueWhereParam);
    impl From<Link> for SetParam {
      fn from(value: Link) -> Self {
        Self::LinkTodoList(value.0)
      }
    }
  }
  pub mod todo_list_id {
    use super::super::*;
    use super::{Cursor, OrderByParam, SetParam, UniqueWhereParam, WhereParam, WithParam};
    pub fn set<T: From<Set>>(value: i32) -> T {
      Set(value).into()
    }
    pub fn equals(value: i32) -> WhereParam {
      WhereParam::TodoListIdEquals(value).into()
    }
    pub fn order(direction: Direction) -> OrderByParam {
      OrderByParam::TodoListId(direction)
    }
    pub fn increment(value: i32) -> SetParam {
      SetParam::IncrementTodoListId(value)
    }
    pub fn decrement(value: i32) -> SetParam {
      SetParam::DecrementTodoListId(value)
    }
    pub fn multiply(value: i32) -> SetParam {
      SetParam::MultiplyTodoListId(value)
    }
    pub fn divide(value: i32) -> SetParam {
      SetParam::DivideTodoListId(value)
    }
    pub fn in_vec(value: Vec<i32>) -> WhereParam {
      WhereParam::TodoListIdInVec(value)
    }
    pub fn not_in_vec(value: Vec<i32>) -> WhereParam {
      WhereParam::TodoListIdNotInVec(value)
    }
    pub fn lt(value: i32) -> WhereParam {
      WhereParam::TodoListIdLt(value)
    }
    pub fn lte(value: i32) -> WhereParam {
      WhereParam::TodoListIdLte(value)
    }
    pub fn gt(value: i32) -> WhereParam {
      WhereParam::TodoListIdGt(value)
    }
    pub fn gte(value: i32) -> WhereParam {
      WhereParam::TodoListIdGte(value)
    }
    pub fn not(value: i32) -> WhereParam {
      WhereParam::TodoListIdNot(value)
    }
    pub struct Set(i32);
    impl From<Set> for SetParam {
      fn from(value: Set) -> Self {
        Self::SetTodoListId(value.0)
      }
    }
  }
  pub mod text {
    use super::super::*;
    use super::{Cursor, OrderByParam, SetParam, UniqueWhereParam, WhereParam, WithParam};
    pub fn set<T: From<Set>>(value: String) -> T {
      Set(value).into()
    }
    pub fn equals(value: String) -> WhereParam {
      WhereParam::TextEquals(value).into()
    }
    pub fn order(direction: Direction) -> OrderByParam {
      OrderByParam::Text(direction)
    }
    pub fn in_vec(value: Vec<String>) -> WhereParam {
      WhereParam::TextInVec(value)
    }
    pub fn not_in_vec(value: Vec<String>) -> WhereParam {
      WhereParam::TextNotInVec(value)
    }
    pub fn lt(value: String) -> WhereParam {
      WhereParam::TextLt(value)
    }
    pub fn lte(value: String) -> WhereParam {
      WhereParam::TextLte(value)
    }
    pub fn gt(value: String) -> WhereParam {
      WhereParam::TextGt(value)
    }
    pub fn gte(value: String) -> WhereParam {
      WhereParam::TextGte(value)
    }
    pub fn contains(value: String) -> WhereParam {
      WhereParam::TextContains(value)
    }
    pub fn starts_with(value: String) -> WhereParam {
      WhereParam::TextStartsWith(value)
    }
    pub fn ends_with(value: String) -> WhereParam {
      WhereParam::TextEndsWith(value)
    }
    pub fn not(value: String) -> WhereParam {
      WhereParam::TextNot(value)
    }
    pub struct Set(String);
    impl From<Set> for SetParam {
      fn from(value: Set) -> Self {
        Self::SetText(value.0)
      }
    }
  }
  pub mod complete {
    use super::super::*;
    use super::{Cursor, OrderByParam, SetParam, UniqueWhereParam, WhereParam, WithParam};
    pub fn set<T: From<Set>>(value: bool) -> T {
      Set(value).into()
    }
    pub fn equals(value: bool) -> WhereParam {
      WhereParam::CompleteEquals(value).into()
    }
    pub fn order(direction: Direction) -> OrderByParam {
      OrderByParam::Complete(direction)
    }
    pub struct Set(bool);
    impl From<Set> for SetParam {
      fn from(value: Set) -> Self {
        Self::SetComplete(value.0)
      }
    }
  }
  pub fn _outputs() -> Vec<Output> {
    vec![
      Output::new("id"),
      Output::new("todoListId"),
      Output::new("text"),
      Output::new("complete"),
    ]
  }
  #[derive(Debug, Clone, Serialize, Deserialize)]
  pub struct Data {
    #[serde(rename = "id")]
    pub id: i32,
    #[serde(rename = "todoList")]
    todo_list: Option<Box<super::todo_list::Data>>,
    #[serde(rename = "todoListId")]
    pub todo_list_id: i32,
    #[serde(rename = "text")]
    pub text: String,
    #[serde(rename = "complete")]
    pub complete: bool,
  }
  impl Data {
    pub fn todo_list(&self) -> Result<&super::todo_list::Data, String> {
      match self.todo_list.as_ref() {
        Some(v) => Ok(v),
        None => Err(
          "Attempted to access todo_list but did not fetch it using the .with() syntax".to_string(),
        ),
      }
    }
  }
  pub enum WithParam {
    TodoList,
  }
  impl WithParam {
    pub fn to_output(self) -> Output {
      match self {
        Self::TodoList => Output {
          name: "todoList".into(),
          outputs: super::todo_list::_outputs(),
          ..Default::default()
        },
      }
    }
  }
  pub enum SetParam {
    SetId(i32),
    IncrementId(i32),
    DecrementId(i32),
    MultiplyId(i32),
    DivideId(i32),
    LinkTodoList(super::todo_list::UniqueWhereParam),
    SetTodoListId(i32),
    IncrementTodoListId(i32),
    DecrementTodoListId(i32),
    MultiplyTodoListId(i32),
    DivideTodoListId(i32),
    SetText(String),
    SetComplete(bool),
  }
  impl SetParam {
    pub fn to_field(self) -> Field {
      match self {
        Self::SetId(value) => Field {
          name: "id".into(),
          value: Some(serde_json::to_value(value).unwrap()),
          ..Default::default()
        },
        Self::IncrementId(value) => Field {
          name: "id".into(),
          fields: Some(vec![Field {
            name: "increment".into(),
            value: Some(serde_json::to_value(value).unwrap()),
            ..Default::default()
          }]),
          ..Default::default()
        },
        Self::DecrementId(value) => Field {
          name: "id".into(),
          fields: Some(vec![Field {
            name: "decrement".into(),
            value: Some(serde_json::to_value(value).unwrap()),
            ..Default::default()
          }]),
          ..Default::default()
        },
        Self::MultiplyId(value) => Field {
          name: "id".into(),
          fields: Some(vec![Field {
            name: "multiply".into(),
            value: Some(serde_json::to_value(value).unwrap()),
            ..Default::default()
          }]),
          ..Default::default()
        },
        Self::DivideId(value) => Field {
          name: "id".into(),
          fields: Some(vec![Field {
            name: "divide".into(),
            value: Some(serde_json::to_value(value).unwrap()),
            ..Default::default()
          }]),
          ..Default::default()
        },
        Self::LinkTodoList(where_param) => Field {
          name: "todoList".into(),
          fields: Some(vec![Field {
            name: "connect".into(),
            fields: Some(transform_equals(vec![
              Into::<super::todo_list::WhereParam>::into(where_param).to_field(),
            ])),
            ..Default::default()
          }]),
          ..Default::default()
        },
        Self::SetTodoListId(value) => Field {
          name: "todoListId".into(),
          value: Some(serde_json::to_value(value).unwrap()),
          ..Default::default()
        },
        Self::IncrementTodoListId(value) => Field {
          name: "todoListId".into(),
          fields: Some(vec![Field {
            name: "increment".into(),
            value: Some(serde_json::to_value(value).unwrap()),
            ..Default::default()
          }]),
          ..Default::default()
        },
        Self::DecrementTodoListId(value) => Field {
          name: "todoListId".into(),
          fields: Some(vec![Field {
            name: "decrement".into(),
            value: Some(serde_json::to_value(value).unwrap()),
            ..Default::default()
          }]),
          ..Default::default()
        },
        Self::MultiplyTodoListId(value) => Field {
          name: "todoListId".into(),
          fields: Some(vec![Field {
            name: "multiply".into(),
            value: Some(serde_json::to_value(value).unwrap()),
            ..Default::default()
          }]),
          ..Default::default()
        },
        Self::DivideTodoListId(value) => Field {
          name: "todoListId".into(),
          fields: Some(vec![Field {
            name: "divide".into(),
            value: Some(serde_json::to_value(value).unwrap()),
            ..Default::default()
          }]),
          ..Default::default()
        },
        Self::SetText(value) => Field {
          name: "text".into(),
          value: Some(serde_json::to_value(value).unwrap()),
          ..Default::default()
        },
        Self::SetComplete(value) => Field {
          name: "complete".into(),
          value: Some(serde_json::to_value(value).unwrap()),
          ..Default::default()
        },
      }
    }
  }
  pub enum OrderByParam {
    Id(Direction),
    TodoListId(Direction),
    Text(Direction),
    Complete(Direction),
  }
  impl OrderByParam {
    pub fn to_field(self) -> Field {
      match self {
        Self::Id(direction) => Field {
          name: "id".into(),
          value: Some(serde_json::to_value(direction).unwrap()),
          ..Default::default()
        },
        Self::TodoListId(direction) => Field {
          name: "todoListId".into(),
          value: Some(serde_json::to_value(direction).unwrap()),
          ..Default::default()
        },
        Self::Text(direction) => Field {
          name: "text".into(),
          value: Some(serde_json::to_value(direction).unwrap()),
          ..Default::default()
        },
        Self::Complete(direction) => Field {
          name: "complete".into(),
          value: Some(serde_json::to_value(direction).unwrap()),
          ..Default::default()
        },
      }
    }
  }
  pub enum Cursor {
    Id(i32),
    TodoListId(i32),
    Text(String),
    Complete(bool),
  }
  impl Cursor {
    fn to_field(self) -> Field {
      match self {
        Self::Id(value) => Field {
          name: "id".into(),
          value: Some(serde_json::to_value(value).unwrap()),
          ..Default::default()
        },
        Self::TodoListId(value) => Field {
          name: "todoListId".into(),
          value: Some(serde_json::to_value(value).unwrap()),
          ..Default::default()
        },
        Self::Text(value) => Field {
          name: "text".into(),
          value: Some(serde_json::to_value(value).unwrap()),
          ..Default::default()
        },
        Self::Complete(value) => Field {
          name: "complete".into(),
          value: Some(serde_json::to_value(value).unwrap()),
          ..Default::default()
        },
      }
    }
  }
  pub enum WhereParam {
    Not(Vec<WhereParam>),
    Or(Vec<WhereParam>),
    And(Vec<WhereParam>),
    IdEquals(i32),
    IdInVec(Vec<i32>),
    IdNotInVec(Vec<i32>),
    IdLt(i32),
    IdLte(i32),
    IdGt(i32),
    IdGte(i32),
    IdNot(i32),
    TodoListIs(Vec<super::todo_list::WhereParam>),
    TodoListIsNot(Vec<super::todo_list::WhereParam>),
    TodoListIdEquals(i32),
    TodoListIdInVec(Vec<i32>),
    TodoListIdNotInVec(Vec<i32>),
    TodoListIdLt(i32),
    TodoListIdLte(i32),
    TodoListIdGt(i32),
    TodoListIdGte(i32),
    TodoListIdNot(i32),
    TextEquals(String),
    TextInVec(Vec<String>),
    TextNotInVec(Vec<String>),
    TextLt(String),
    TextLte(String),
    TextGt(String),
    TextGte(String),
    TextContains(String),
    TextStartsWith(String),
    TextEndsWith(String),
    TextNot(String),
    CompleteEquals(bool),
  }
  impl WhereParam {
    pub fn to_field(self) -> Field {
      match self {
        Self::Not(value) => Field {
          name: "NOT".into(),
          list: true,
          wrap_list: true,
          fields: Some(value.into_iter().map(|f| f.to_field()).collect()),
          ..Default::default()
        },
        Self::Or(value) => Field {
          name: "OR".into(),
          list: true,
          wrap_list: true,
          fields: Some(value.into_iter().map(|f| f.to_field()).collect()),
          ..Default::default()
        },
        Self::And(value) => Field {
          name: "AND".into(),
          list: true,
          wrap_list: true,
          fields: Some(value.into_iter().map(|f| f.to_field()).collect()),
          ..Default::default()
        },
        Self::IdEquals(value) => Field {
          name: "id".into(),
          fields: Some(vec![Field {
            name: "equals".into(),
            value: Some(serde_json::to_value(value).unwrap()),
            ..Default::default()
          }]),
          ..Default::default()
        },
        Self::IdInVec(value) => Field {
          name: "id".into(),
          fields: Some(vec![Field {
            name: "in".into(),
            list: true,
            fields: Some(
              value
                .iter()
                .map(|v| Field {
                  value: Some(serde_json::to_value(v).unwrap()),
                  ..Default::default()
                })
                .collect(),
            ),
            ..Default::default()
          }]),
          ..Default::default()
        },
        Self::IdNotInVec(value) => Field {
          name: "id".into(),
          fields: Some(vec![Field {
            name: "notIn".into(),
            list: true,
            fields: Some(
              value
                .iter()
                .map(|v| Field {
                  value: Some(serde_json::to_value(v).unwrap()),
                  ..Default::default()
                })
                .collect(),
            ),
            ..Default::default()
          }]),
          ..Default::default()
        },
        Self::IdLt(value) => Field {
          name: "id".into(),
          fields: Some(vec![Field {
            name: "lt".into(),
            value: Some(serde_json::to_value(value).unwrap()),
            ..Default::default()
          }]),
          ..Default::default()
        },
        Self::IdLte(value) => Field {
          name: "id".into(),
          fields: Some(vec![Field {
            name: "lte".into(),
            value: Some(serde_json::to_value(value).unwrap()),
            ..Default::default()
          }]),
          ..Default::default()
        },
        Self::IdGt(value) => Field {
          name: "id".into(),
          fields: Some(vec![Field {
            name: "gt".into(),
            value: Some(serde_json::to_value(value).unwrap()),
            ..Default::default()
          }]),
          ..Default::default()
        },
        Self::IdGte(value) => Field {
          name: "id".into(),
          fields: Some(vec![Field {
            name: "gte".into(),
            value: Some(serde_json::to_value(value).unwrap()),
            ..Default::default()
          }]),
          ..Default::default()
        },
        Self::IdNot(value) => Field {
          name: "id".into(),
          fields: Some(vec![Field {
            name: "not".into(),
            value: Some(serde_json::to_value(value).unwrap()),
            ..Default::default()
          }]),
          ..Default::default()
        },
        Self::TodoListIs(value) => Field {
          name: "todoList".into(),
          fields: Some(vec![Field {
            name: "is".into(),
            fields: Some(value.into_iter().map(|f| f.to_field()).collect()),
            ..Default::default()
          }]),
          ..Default::default()
        },
        Self::TodoListIsNot(value) => Field {
          name: "todoList".into(),
          fields: Some(vec![Field {
            name: "isNot".into(),
            fields: Some(value.into_iter().map(|f| f.to_field()).collect()),
            ..Default::default()
          }]),
          ..Default::default()
        },
        Self::TodoListIdEquals(value) => Field {
          name: "todoListId".into(),
          fields: Some(vec![Field {
            name: "equals".into(),
            value: Some(serde_json::to_value(value).unwrap()),
            ..Default::default()
          }]),
          ..Default::default()
        },
        Self::TodoListIdInVec(value) => Field {
          name: "todoListId".into(),
          fields: Some(vec![Field {
            name: "in".into(),
            list: true,
            fields: Some(
              value
                .iter()
                .map(|v| Field {
                  value: Some(serde_json::to_value(v).unwrap()),
                  ..Default::default()
                })
                .collect(),
            ),
            ..Default::default()
          }]),
          ..Default::default()
        },
        Self::TodoListIdNotInVec(value) => Field {
          name: "todoListId".into(),
          fields: Some(vec![Field {
            name: "notIn".into(),
            list: true,
            fields: Some(
              value
                .iter()
                .map(|v| Field {
                  value: Some(serde_json::to_value(v).unwrap()),
                  ..Default::default()
                })
                .collect(),
            ),
            ..Default::default()
          }]),
          ..Default::default()
        },
        Self::TodoListIdLt(value) => Field {
          name: "todoListId".into(),
          fields: Some(vec![Field {
            name: "lt".into(),
            value: Some(serde_json::to_value(value).unwrap()),
            ..Default::default()
          }]),
          ..Default::default()
        },
        Self::TodoListIdLte(value) => Field {
          name: "todoListId".into(),
          fields: Some(vec![Field {
            name: "lte".into(),
            value: Some(serde_json::to_value(value).unwrap()),
            ..Default::default()
          }]),
          ..Default::default()
        },
        Self::TodoListIdGt(value) => Field {
          name: "todoListId".into(),
          fields: Some(vec![Field {
            name: "gt".into(),
            value: Some(serde_json::to_value(value).unwrap()),
            ..Default::default()
          }]),
          ..Default::default()
        },
        Self::TodoListIdGte(value) => Field {
          name: "todoListId".into(),
          fields: Some(vec![Field {
            name: "gte".into(),
            value: Some(serde_json::to_value(value).unwrap()),
            ..Default::default()
          }]),
          ..Default::default()
        },
        Self::TodoListIdNot(value) => Field {
          name: "todoListId".into(),
          fields: Some(vec![Field {
            name: "not".into(),
            value: Some(serde_json::to_value(value).unwrap()),
            ..Default::default()
          }]),
          ..Default::default()
        },
        Self::TextEquals(value) => Field {
          name: "text".into(),
          fields: Some(vec![Field {
            name: "equals".into(),
            value: Some(serde_json::to_value(value).unwrap()),
            ..Default::default()
          }]),
          ..Default::default()
        },
        Self::TextInVec(value) => Field {
          name: "text".into(),
          fields: Some(vec![Field {
            name: "in".into(),
            list: true,
            fields: Some(
              value
                .iter()
                .map(|v| Field {
                  value: Some(serde_json::to_value(v).unwrap()),
                  ..Default::default()
                })
                .collect(),
            ),
            ..Default::default()
          }]),
          ..Default::default()
        },
        Self::TextNotInVec(value) => Field {
          name: "text".into(),
          fields: Some(vec![Field {
            name: "notIn".into(),
            list: true,
            fields: Some(
              value
                .iter()
                .map(|v| Field {
                  value: Some(serde_json::to_value(v).unwrap()),
                  ..Default::default()
                })
                .collect(),
            ),
            ..Default::default()
          }]),
          ..Default::default()
        },
        Self::TextLt(value) => Field {
          name: "text".into(),
          fields: Some(vec![Field {
            name: "lt".into(),
            value: Some(serde_json::to_value(value).unwrap()),
            ..Default::default()
          }]),
          ..Default::default()
        },
        Self::TextLte(value) => Field {
          name: "text".into(),
          fields: Some(vec![Field {
            name: "lte".into(),
            value: Some(serde_json::to_value(value).unwrap()),
            ..Default::default()
          }]),
          ..Default::default()
        },
        Self::TextGt(value) => Field {
          name: "text".into(),
          fields: Some(vec![Field {
            name: "gt".into(),
            value: Some(serde_json::to_value(value).unwrap()),
            ..Default::default()
          }]),
          ..Default::default()
        },
        Self::TextGte(value) => Field {
          name: "text".into(),
          fields: Some(vec![Field {
            name: "gte".into(),
            value: Some(serde_json::to_value(value).unwrap()),
            ..Default::default()
          }]),
          ..Default::default()
        },
        Self::TextContains(value) => Field {
          name: "text".into(),
          fields: Some(vec![Field {
            name: "contains".into(),
            value: Some(serde_json::to_value(value).unwrap()),
            ..Default::default()
          }]),
          ..Default::default()
        },
        Self::TextStartsWith(value) => Field {
          name: "text".into(),
          fields: Some(vec![Field {
            name: "startsWith".into(),
            value: Some(serde_json::to_value(value).unwrap()),
            ..Default::default()
          }]),
          ..Default::default()
        },
        Self::TextEndsWith(value) => Field {
          name: "text".into(),
          fields: Some(vec![Field {
            name: "endsWith".into(),
            value: Some(serde_json::to_value(value).unwrap()),
            ..Default::default()
          }]),
          ..Default::default()
        },
        Self::TextNot(value) => Field {
          name: "text".into(),
          fields: Some(vec![Field {
            name: "not".into(),
            value: Some(serde_json::to_value(value).unwrap()),
            ..Default::default()
          }]),
          ..Default::default()
        },
        Self::CompleteEquals(value) => Field {
          name: "complete".into(),
          fields: Some(vec![Field {
            name: "equals".into(),
            value: Some(serde_json::to_value(value).unwrap()),
            ..Default::default()
          }]),
          ..Default::default()
        },
      }
    }
  }
  pub enum UniqueWhereParam {
    IdEquals(i32),
  }
  impl From<UniqueWhereParam> for WhereParam {
    fn from(value: UniqueWhereParam) -> Self {
      match value {
        UniqueWhereParam::IdEquals(value) => Self::IdEquals(value),
      }
    }
  }
  impl From<Operator<Self>> for WhereParam {
    fn from(op: Operator<Self>) -> Self {
      match op {
        Operator::Not(value) => Self::Not(value),
        Operator::And(value) => Self::And(value),
        Operator::Or(value) => Self::Or(value),
      }
    }
  }
  pub struct FindMany<'a> {
    query: Query<'a>,
    order_by_params: Vec<OrderByParam>,
    with_params: Vec<WithParam>,
  }
  impl<'a> FindMany<'a> {
    pub async fn exec(self) -> QueryResult<Vec<Data>> {
      let Self {
        mut query,
        order_by_params,
        with_params,
      } = self;
      if order_by_params.len() > 0 {
        query.inputs.push(Input {
          name: "orderBy".into(),
          fields: order_by_params.into_iter().map(|f| f.to_field()).collect(),
          ..Default::default()
        });
      }
      query.outputs.extend(
        with_params
          .into_iter()
          .map(|f| f.to_output())
          .collect::<Vec<_>>(),
      );
      query.perform().await
    }
    pub fn delete(self) -> DeleteMany<'a> {
      DeleteMany {
        query: Query {
          operation: "mutation".into(),
          method: "deleteMany".into(),
          model: "TodoItem".into(),
          outputs: vec![Output::new("count")],
          ..self.query
        },
      }
    }
    pub fn update(mut self, params: Vec<SetParam>) -> UpdateMany<'a> {
      self.query.inputs.push(Input {
        name: "data".into(),
        fields: params
          .into_iter()
          .map(|param| {
            let mut field = param.to_field();
            if let Some(value) = field.value {
              field.fields = Some(vec![Field {
                name: "set".into(),
                value: Some(value),
                ..Default::default()
              }]);
              field.value = None;
            }
            field
          })
          .collect(),
        ..Default::default()
      });
      UpdateMany {
        query: Query {
          operation: "mutation".into(),
          method: "updateMany".into(),
          outputs: vec![Output::new("count")],
          ..self.query
        },
      }
    }
    pub fn order_by(mut self, param: OrderByParam) -> Self {
      self.order_by_params.push(param);
      self
    }
    pub fn with(mut self, param: WithParam) -> Self {
      self.with_params.push(param);
      self
    }
    pub fn skip(mut self, skip: usize) -> Self {
      self.query.inputs.push(Input {
        name: "skip".into(),
        value: Some(serde_json::to_value(skip).unwrap()),
        ..Default::default()
      });
      self
    }
    pub fn take(mut self, take: usize) -> Self {
      self.query.inputs.push(Input {
        name: "take".into(),
        value: Some(serde_json::to_value(take).unwrap()),
        ..Default::default()
      });
      self
    }
    pub fn cursor(mut self, cursor: Cursor) -> Self {
      self.query.inputs.push(Input {
        name: "cursor".into(),
        fields: vec![cursor.to_field()],
        ..Default::default()
      });
      self
    }
  }
  pub struct FindFirst<'a> {
    query: Query<'a>,
    order_by_params: Vec<OrderByParam>,
    with_params: Vec<WithParam>,
  }
  impl<'a> FindFirst<'a> {
    pub async fn exec(self) -> QueryResult<Option<Data>> {
      let Self {
        mut query,
        order_by_params,
        with_params,
      } = self;
      if order_by_params.len() > 0 {
        query.inputs.push(Input {
          name: "orderBy".into(),
          fields: order_by_params.into_iter().map(|f| f.to_field()).collect(),
          ..Default::default()
        });
      }
      query.outputs.extend(
        with_params
          .into_iter()
          .map(|f| f.to_output())
          .collect::<Vec<_>>(),
      );
      query.perform().await
    }
    pub fn with(mut self, param: WithParam) -> Self {
      self.with_params.push(param);
      self
    }
    pub fn order_by(mut self, param: OrderByParam) -> Self {
      self.order_by_params.push(param);
      self
    }
    pub fn skip(mut self, skip: usize) -> Self {
      self.query.inputs.push(Input {
        name: "skip".into(),
        value: Some(serde_json::to_value(skip).unwrap()),
        ..Default::default()
      });
      self
    }
    pub fn take(mut self, take: usize) -> Self {
      self.query.inputs.push(Input {
        name: "take".into(),
        value: Some(serde_json::to_value(take).unwrap()),
        ..Default::default()
      });
      self
    }
    pub fn cursor(mut self, cursor: Cursor) -> Self {
      self.query.inputs.push(Input {
        name: "cursor".into(),
        fields: vec![cursor.to_field()],
        ..Default::default()
      });
      self
    }
  }
  pub struct FindUnique<'a> {
    query: Query<'a>,
    with_params: Vec<WithParam>,
  }
  impl<'a> FindUnique<'a> {
    pub async fn exec(self) -> QueryResult<Option<Data>> {
      let Self {
        mut query,
        with_params,
      } = self;
      query.outputs.extend(
        with_params
          .into_iter()
          .map(|f| f.to_output())
          .collect::<Vec<_>>(),
      );
      query.perform().await
    }
    pub fn delete(self) -> Delete<'a> {
      Delete {
        query: Query {
          operation: "mutation".into(),
          method: "deleteOne".into(),
          model: "TodoItem".into(),
          ..self.query
        },
        with_params: vec![],
      }
    }
    pub fn update(mut self, params: Vec<SetParam>) -> UpdateUnique<'a> {
      self.query.inputs.push(Input {
        name: "data".into(),
        fields: params
          .into_iter()
          .map(|param| {
            let mut field = param.to_field();
            if let Some(value) = field.value {
              field.fields = Some(vec![Field {
                name: "set".into(),
                value: Some(value),
                ..Default::default()
              }]);
              field.value = None;
            }
            field
          })
          .collect(),
        ..Default::default()
      });
      UpdateUnique {
        query: Query {
          operation: "mutation".into(),
          method: "updateOne".into(),
          ..self.query
        },
        with_params: vec![],
      }
    }
    pub fn with(mut self, param: WithParam) -> Self {
      self.with_params.push(param);
      self
    }
  }
  pub struct Create<'a> {
    query: Query<'a>,
    with_params: Vec<WithParam>,
  }
  impl<'a> Create<'a> {
    pub async fn exec(self) -> QueryResult<Data> {
      let Self {
        mut query,
        with_params,
      } = self;
      query.outputs.extend(
        with_params
          .into_iter()
          .map(|f| f.to_output())
          .collect::<Vec<_>>(),
      );
      query.perform().await
    }
    pub fn with(mut self, param: WithParam) -> Self {
      self.with_params.push(param);
      self
    }
  }
  pub struct UpdateUnique<'a> {
    query: Query<'a>,
    with_params: Vec<WithParam>,
  }
  impl<'a> UpdateUnique<'a> {
    pub async fn exec(self) -> QueryResult<Option<Data>> {
      let Self {
        mut query,
        with_params,
      } = self;
      query.outputs.extend(
        with_params
          .into_iter()
          .map(|f| f.to_output())
          .collect::<Vec<_>>(),
      );
      match query.perform().await {
        Err(QueryError::Execute(CoreError::InterpreterError(
          InterpreterError::InterpretationError(msg, Some(interpreter_error)),
        ))) => match *interpreter_error {
          InterpreterError::QueryGraphBuilderError(QueryGraphBuilderError::RecordNotFound(_)) => {
            Ok(None)
          }
          res => Err(QueryError::Execute(CoreError::InterpreterError(
            InterpreterError::InterpretationError(msg, Some(Box::new(res))),
          ))),
        },
        res => res,
      }
    }
    pub fn with(mut self, param: WithParam) -> Self {
      self.with_params.push(param);
      self
    }
  }
  pub struct UpdateMany<'a> {
    query: Query<'a>,
  }
  impl<'a> UpdateMany<'a> {
    pub async fn exec(self) -> QueryResult<usize> {
      self.query.perform().await.map(|res: CountResult| res.count)
    }
  }
  pub struct Upsert<'a> {
    query: Query<'a>,
  }
  impl<'a> Upsert<'a> {
    pub async fn exec(self) -> QueryResult<Data> {
      self.query.perform().await
    }
    pub fn create(
      mut self,
      todo_list: todo_list::Link,
      text: text::Set,
      params: Vec<SetParam>,
    ) -> Self {
      let mut input_fields = params.into_iter().map(|p| p.to_field()).collect::<Vec<_>>();
      input_fields.push(SetParam::from(todo_list).to_field());
      input_fields.push(SetParam::from(text).to_field());
      self.query.inputs.push(Input {
        name: "create".into(),
        fields: input_fields,
        ..Default::default()
      });
      self
    }
    pub fn update(mut self, params: Vec<SetParam>) -> Self {
      self.query.inputs.push(Input {
        name: "update".into(),
        fields: params
          .into_iter()
          .map(|param| {
            let mut field = param.to_field();
            if let Some(value) = field.value {
              field.fields = Some(vec![Field {
                name: "set".into(),
                value: Some(value),
                ..Default::default()
              }]);
              field.value = None;
            }
            field
          })
          .collect(),
        ..Default::default()
      });
      self
    }
  }
  pub struct Delete<'a> {
    query: Query<'a>,
    with_params: Vec<WithParam>,
  }
  impl<'a> Delete<'a> {
    pub async fn exec(self) -> QueryResult<Option<Data>> {
      let Self {
        mut query,
        with_params,
      } = self;
      query.outputs.extend(
        with_params
          .into_iter()
          .map(|f| f.to_output())
          .collect::<Vec<_>>(),
      );
      match query.perform().await {
        Err(QueryError::Execute(CoreError::InterpreterError(
          InterpreterError::InterpretationError(msg, Some(interpreter_error)),
        ))) => match *interpreter_error {
          InterpreterError::QueryGraphBuilderError(QueryGraphBuilderError::RecordNotFound(_)) => {
            Ok(None)
          }
          res => Err(QueryError::Execute(CoreError::InterpreterError(
            InterpreterError::InterpretationError(msg, Some(Box::new(res))),
          ))),
        },
        res => res,
      }
    }
    pub fn with(mut self, param: WithParam) -> Self {
      self.with_params.push(param);
      self
    }
  }
  pub struct DeleteMany<'a> {
    query: Query<'a>,
  }
  impl<'a> DeleteMany<'a> {
    pub async fn exec(self) -> QueryResult<usize> {
      self.query.perform().await.map(|res: CountResult| res.count)
    }
  }
  pub struct Actions<'a> {
    pub client: &'a PrismaClient,
  }
  impl<'a> Actions<'a> {
    pub fn create(
      &self,
      todo_list: todo_list::Link,
      text: text::Set,
      params: Vec<SetParam>,
    ) -> Create {
      let mut input_fields = params.into_iter().map(|p| p.to_field()).collect::<Vec<_>>();
      input_fields.push(SetParam::from(todo_list).to_field());
      input_fields.push(SetParam::from(text).to_field());
      let query = Query {
        ctx: QueryContext::new(&self.client.executor, self.client.query_schema.clone()),
        name: String::new(),
        operation: "mutation".into(),
        method: "createOne".into(),
        model: "TodoItem".into(),
        outputs: _outputs(),
        inputs: vec![Input {
          name: "data".into(),
          fields: input_fields,
          ..Default::default()
        }],
      };
      Create {
        query,
        with_params: vec![],
      }
    }
    pub fn find_unique(&self, param: UniqueWhereParam) -> FindUnique {
      let param: WhereParam = param.into();
      let fields = transform_equals(vec![param.to_field()]);
      let query = Query {
        ctx: QueryContext::new(&self.client.executor, self.client.query_schema.clone()),
        name: String::new(),
        operation: "query".into(),
        method: "findUnique".into(),
        model: "TodoItem".into(),
        outputs: _outputs(),
        inputs: vec![Input {
          name: "where".into(),
          fields,
          ..Default::default()
        }],
      };
      FindUnique {
        query,
        with_params: vec![],
      }
    }
    pub fn find_first(&self, params: Vec<WhereParam>) -> FindFirst {
      let where_fields: Vec<Field> = params.into_iter().map(|param| param.to_field()).collect();
      let inputs = if where_fields.len() > 0 {
        vec![Input {
          name: "where".into(),
          fields: vec![Field {
            name: "AND".into(),
            list: true,
            wrap_list: true,
            fields: Some(where_fields),
            ..Default::default()
          }],
          ..Default::default()
        }]
      } else {
        Vec::new()
      };
      let query = Query {
        ctx: QueryContext::new(&self.client.executor, self.client.query_schema.clone()),
        name: String::new(),
        operation: "query".into(),
        method: "findFirst".into(),
        model: "TodoItem".into(),
        outputs: _outputs(),
        inputs,
      };
      FindFirst {
        query,
        order_by_params: vec![],
        with_params: vec![],
      }
    }
    pub fn find_many(&self, params: Vec<WhereParam>) -> FindMany {
      let where_fields: Vec<Field> = params.into_iter().map(|param| param.to_field()).collect();
      let inputs = if where_fields.len() > 0 {
        vec![Input {
          name: "where".into(),
          fields: where_fields,
          ..Default::default()
        }]
      } else {
        Vec::new()
      };
      let query = Query {
        ctx: QueryContext::new(&self.client.executor, self.client.query_schema.clone()),
        name: String::new(),
        operation: "query".into(),
        method: "findMany".into(),
        model: "TodoItem".into(),
        outputs: _outputs(),
        inputs,
      };
      FindMany {
        query,
        order_by_params: vec![],
        with_params: vec![],
      }
    }
    pub fn upsert(&self, param: UniqueWhereParam) -> Upsert {
      let param: WhereParam = param.into();
      let fields = transform_equals(vec![param.to_field()]);
      let query = Query {
        ctx: QueryContext::new(&self.client.executor, self.client.query_schema.clone()),
        name: String::new(),
        operation: "mutation".into(),
        method: "upsertOne".into(),
        model: "TodoItem".into(),
        outputs: _outputs(),
        inputs: vec![Input {
          name: "where".into(),
          fields,
          ..Default::default()
        }],
      };
      Upsert { query }
    }
  }
}
#[derive(Debug, Clone, Copy, Serialize, Deserialize)]
pub enum TodoListScalarFieldEnum {
  #[serde(rename = "id")]
  Id,
  #[serde(rename = "name")]
  Name,
}
#[derive(Debug, Clone, Copy, Serialize, Deserialize)]
pub enum TodoItemScalarFieldEnum {
  #[serde(rename = "id")]
  Id,
  #[serde(rename = "todoListId")]
  TodoListId,
  #[serde(rename = "text")]
  Text,
  #[serde(rename = "complete")]
  Complete,
}
#[derive(Debug, Clone, Copy, Serialize, Deserialize)]
pub enum SortOrder {
  #[serde(rename = "asc")]
  Asc,
  #[serde(rename = "desc")]
  Desc,
}
